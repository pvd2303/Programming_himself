# ЧАСТЬ III
# Введение в инструменты программирования
# p141
# Глава 16 bash**********
# bash - интерфейс коммандной строки

"""
Командная строка, системы управления пакетами,
регулярные выражения и управление
версиями - основные инструменты в арсенале программиста.
"""
# Запуск bash**********
# Команды **********
# Команды в bash в Ubuntu Linux
"""
$echo как print
$python3 - запускаем Питон
$exit() - выход их Питон
$history - список последних команд
$pwd - print working directory - вывод рабочего каталога
$/home/pvd - мой рабочий каталог
$cd / - переход в корневой каталог ОС
$ls - выводит каталоги и папки в текущем рабочем каталоге
$cd ~ - перемещение в свой домашний каталог
$mkdir - создает новый каталог (папку)
$cd tstp - перейти в каталог tstp
$cd .. - перейти на каталог выше
$rmdir - удаление каталога
$/mnt/c - просмотр содержимого диска с
"""
# ФЛаги**********
"""
Флаги - это опции для команд, принимающие значения True или False
По умолчанию изначальное значение всех флагов - False
чтобы изменить флаг на True, перед именем нужно указать один или два дефиса
ls -autor - выводит все каталоги и файлы в каталоге, а также выводит имя 
владельца
"""

# СКрытые файлы**********
"""
Имена скрытых файлов начинаются с точки.
.self_taught
Чтобы увидеть скрытые файлы нужно добавить к команде ls флаг -a
$ls -a
$touch .self_taught - создание скрытого файла
"""
#Вертикальная черта**********
"""
Символ | называют пайп.
Этот символ можно использовать для передачи вывода
команды в другую команду в качестве ее ввода.
$ls | less
"""
# Переменные окружения**********
"""
Новая переменная окружения создается при помощи
синтаксиса "export ямя_переменной= значение переменной".
Чтобы сослаться на переменную окружения, 
нужно указать перед ее именем символ $.
$export x=100
$echo $x
"""
# Пользователи**********
"""
$whoami - получить имя пользователя
$sudo - superuser do - выполняет суперпользователь
Эта команда нужна, что бы запускать программы 
с правами администратора
habrahabr.ru/post/47163 - здесь больше по использованию bash
"""

"""
#1
#!/bin/bash
echo Self-taught

#2
#!/bin/bash
cd /home/pvd
cd home/pvd

#3
#!/bin/bash
# добавляет строку в файл .profile.
export python_projects=~
cd $python_projects
"""

# Глава 17. Регулярные выражения**********
# Настройка**********
#p150
"""
Переход на другие диски
$ cd /mnt/h - переход на диск H
"""

#Простое совпадение**********
"""
Поиск совпадений слова Красивое в фале zen.txt
$ grep Красивое zen.txt

Флаг -i позволяет не учитывать регистр букв
$ grep -i красивое zen.txt

По умолчанию команда grep выводит всю строку файла,
в котором она нашла совпадение. Чтобы выводить только
конкретные слова, совпадающие с переданным шаблоном, 
добавьте флаг -о.
$ grep -o Красивое zen.txt
"""

"""
Вы можете использовать регулярные выражения в Python 
при помощи встроенной библиотеки re (от англ. 
словосочетания regular expressions — регулярные 
выражения). В модуле re есть метод findall.
 
"""
import re
l = "Красивое лучше, чем уродливое."
matches = re.findall("Красивое", l)
print(matches)
# можно не учитывать регистр
matches = re.findall("красивое", l, re.IGNORECASE)
print(matches)

# Совпадение в начале и в конце*********
"""
$ grep ^Если zen.txt
$ grep никогда.$ zen.txt
"""
"""
Пример использования символа каретки (^) в Python 
(вы должны передать значение re.MULTILINE в качестве 
третьего параметра методу findall, чтобы искать 
совпадения во всех строках многострочного экрана)
"""
zen = """Хотя никогда зачастую лучше, чем прямо сейчас.
Если реализацию сложно объяснить — идея плоха.
Если реализацию легко объяснить — идея, возможно, хороша.
Пространства имен — отличная штука! Будем делать их побольше!"""

m = re.findall("^Если",
               zen,
               re.MULTILINE)
print(m)

#Поиск совпадений с нескольскими символами***********
"""
bash
шаблон для поиска совпадений с несколькими символами
поместите эти символы внутрь квадратных скобок 
в регулярном выражении

$ echo Два даа. | grep -i д[ав]а
Вывод команды echo передается в grep в качестве ввода
и, следовательно, вам не нужно указывать файл в качестве
параметра для grep. 
Команда выводит и Два, и даа, поскольку регулярное 
выражение находит совпадение с буквой д, затем либо 
с а, либо с в. и затем — с а.
"""
"""
в Python
"""
string = "Два даа."
m = re.findall("д[ав]а",
               string,
               re.IGNORECASE)
print(m)

# Совпадение цифр**********
"""
bash
$ echo 123 хай 34 привет. | grep [[:digit:]]
символ | передает строку 123 хай 34 привет. на ввод
оператора grep
"""
"""
в Python для этого используется символ \d
"""
line = "123?34 привет?"
m = re.findall("\d",
               line,
               re.IGNORECASE)
print(m)

# Повторение**********
"""
bash
Символ звездочки (*) добавляет в регулярные выражения 
повторение. При его помощи «предшествующий элемент 
будет найден ноль или более раз.

$ echo ту тууу ура. | grep -o ту*

В регулярных выражениях точка соответствует любому 
символу. Если вы укажете звездочку после точки, 
будет выполняться поиск совпадения с любым символом 
ноль или более раз. Можно использовать точку со 
звездочкой для поиска всего, что находится в промежутке
между двумя символами.

$ echo __привет__всем | grep -o __.*__

Символ звездочки является жадным — это значит, что 
он попытается найти столько текста, сколько сможет
"""

"""
в Python
Чтобы сделать регулярное выражение нежадным, 
можно указать после звездочки вопросительный знак. 
"""
t = "__один__ __два__ __три__"
found = re.findall("__.*?__", t)
for match in found:
    print(match)

# Игра "ЧЕПУХА"
# игроку предлагается вставить пропущенные в абзаце
# текста слова

import re

text = """Жирафы любят таскать
 различные __СУЩЕСТВИТЕЛЬНОЕ ВО МНОЖЕСТВЕННОМ ЧИСЛЕ__
 целый день напролет. Жирафы
 также славятся тем, что поедают
 прекрасные __СУЩЕСТВИТЕЛЬНОЕ ВО МНОЖЕСТВЕННОМ ЧИСЛЕ__, но
 после этого у них часто
 болит __ЧАСТЬ_ТЕЛА__. Если же
 жирафы находят __ЧИСЛО__
 __СУЩЕСТВИТЕЛЬНОЕ ВО МНОЖЕСТВЕННОМ ЧИСЛЕ__, у
 них моментально отваливается __ЧАСТЬ ТЕЛА__.
"""

def mad_libs(mls):
    """
    :param mls: В строках
    пользовательский ввод
    должен быть окружен двойными
    подчеркиваниями. Подчеркивания
    нельзя вставлять в подсказку:
    __подсказка_подсказка__ (нельзя);
    __подсказка__ (можно).
    """
    hints = re.findall("__.*?__",
                       mls)
    if hints is not None:
        for word in hints:
            q = "Введите {}".format(word)
            new = input(q)
            mls = mls.replace(word, new, 1)
        print('\n')
        mls = mls.replace("\n", "")
        print(mls)
    else:
        print("ошибка ввода")

mad_libs(text)

# Управляющие символы**********
"""
bash
В регулярных выражениях вы можете экранировать 
символы (игнорировать их значение, просто находя 
совпадения)

$ echo Я люблю $ | grep \$

Обычно символ $ означает, что совпадение допустимо, 
только если оно находится в конце строки, но поскольку 
вы экранировали этот знак, регулярное выражение 
просто найдет совпадение.
"""
"""
Этот же пример в Python
"""
line = "Я люблю $"
m = re.findall("\\$",
               line,
               re.IGNORECASE)

print(m)

# Практикум ====================================
#1
"""
$ grep голландец zen.txt
"""
#2
"""
echo Москва: 777, 999, 797. Тула: 071, 950, 112. | grep [[:digit:]]

"""
#3
import re

text = "Привидение прошуршало и исчезло в углу."

m = re.findall("[аз]ло",
               text,
               re.IGNORECASE)
print(m)

m = re.findall(".ло", text)
print(m)














